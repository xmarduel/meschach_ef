/*
 * VOGL/VOGLE driver for X11.
 * 
 * Define VOGLE if this driver is really for the VOGLE Libarary.
 *
 */
#define VOGLE 1

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>

#ifdef VOGLE

#include "vogle.h"
static	char	*me = "vogle";
#define LARGEFONT       "-adobe-courier-medium-r-normal--24-240-75-75-m-150-iso8859-1"
#define SMALLFONT       "-adobe-courier-medium-r-normal--10-100-75-75-m-60-iso8859-1"

#else

#include "vogl.h"
static	char	*me = "vogl";
#define LARGEFONT	"9x15bold"
#define SMALLFONT	"6x13bold"

#endif

static	char	*xdisp = (char *)NULL;

#define MIN(x,y)	((x) < (y) ? (x) : (y))
#define MAX(x,y)	((x) > (y) ? (x) : (y))
#define	CMAPSIZE	256
#define	EV_MASK		KeyPressMask|ButtonReleaseMask|ExposureMask|ButtonPressMask
#define	MAXPNTS		256

int		maxw = -1, maxh = -1;

/*
 * This defines an instance of an X11 device.
 */
typedef struct {
	Window		winder;
	int		id;		/* Vogle's window id */
	Display		*display;
	int		screen;
	unsigned long	carray[CMAPSIZE];
	Colormap	colormap;
	Drawable	theDrawable;
	GC		theGC;
	XGCValues	theGCvalues;
	Pixmap		bbuf;		/* Back buffer pixmap */
	XFontStruct	*font_id;
	unsigned long	colour;
	unsigned int	h, w;
	char		*smallf, *largef;
	char		*title;
	char		back_used;
	char		privatecmap;
	char		depth;
	char		initialized;
} X11_rec;

static	X11_rec		*x11;

XEvent			event;


#if 0
/*
 * vo_xt_set_win
 *
 *	Just sets the drawable to the partucular window.
 */
vo_xt_set_win(dis, win, xw, xh)
	Display	*dis;
	Window	win;
	int	xw, xh;
{
	int	backb;

	x11->winder = win;

	vdevice.sizeX = vdevice.sizeY = MIN(xh, xw);
	vdevice.sizeSx = xw;
	vdevice.sizeSy = xh;

        if (xw > maxw || xh > maxh) {
		if (x11->back_used) {
			x11->back_used = 0;
			XFreePixmap(x11->display, x11->bbuf);
			X11_backbuf();
		}
        }

	x11->display = dis;
	if (backb)
		x11->theDrawable = x11->bbuf;
	else
		x11->theDrawable = win;

	return(1);
}
/*

 */
vo_xt_window(dis, win, xw, xh)
	Display	*dis;
	Window	win;
	int	xw, xh;
{
	int	backb, i, depth;

	x11 = dx11;
	backb = (x11->theDrawable == x11->bbuf);

	x11->display = dis;
	x11->winder = win;
	x11->screen = DefaultScreen(x11->display);
	x11->colormap = DefaultColormap(x11->display, x11->screen);
	x11->depth = vdevice.depth = DefaultDepth(x11->display, x11->screen);
	x11->theDrawable = x11->winder;

	use_toolkit_win = 1;
	x11->w = xw;
	x11->h = xh;

	/*
	 * Set our standard colors...
	 */
	if (vdevice.depth == 1) {
		/*
		 * Black and white - anything that's not black is white.
		 */
		x11->carray[0] = BlackPixel(x11->display, x11->screen);
		for (i = 1; i < CMAPSIZE; i++)
			x11->carray[i] = WhitePixel(x11->display, x11->screen);
	} else {
		/*
		 * Color, try to get our colors close to what's in the
		 * default colormap.
		 */
		X11_mapcolor(0, 0, 0, 0);
		X11_mapcolor(1, 255, 0, 0);
		X11_mapcolor(2, 0, 255, 0);
		X11_mapcolor(3, 255, 255, 0);
		X11_mapcolor(4, 0, 0, 255);
		X11_mapcolor(5, 255, 0, 255);
		X11_mapcolor(6, 0, 255, 255);
		X11_mapcolor(7, 255, 255, 255);
	}

	if ((x11->smallf = XGetDefault(x11->display, me, "smallfont")) == (char *)NULL)
		x11->smallf = SMALLFONT;

	if ((x11->largef = XGetDefault(x11->display, me, "largefont")) == (char *)NULL)
		x11->largef = LARGEFONT;

	/*
	 * Create Graphics Context and Drawable
	 */
	x11->theGC = XDefaultGC(x11->display, x11->screen);
	x11->theGCvalues.graphics_exposures = False;
	x11->theGCvalues.cap_style = CapButt;
	XChangeGC(x11->display, x11->theGC, GCGraphicsExposures|GCCapStyle, &x11->theGCvalues);
	X11_color(0);

	vdevice.sizeX = vdevice.sizeY = MIN(xh, xw);
	vdevice.sizeSx = xw;
	vdevice.sizeSy = xh;

        if (x11->back_used && (xw > maxw || xh > maxh)) {
                x11->back_used = 0;
		XFreePixmap(x11->display, x11->bbuf);
                X11_backbuf();
        }

	if (backb)
		x11->theDrawable = x11->bbuf;
	else
		x11->theDrawable = win;


#ifndef VOGLE
	vdevice.devname = "X11";
#endif

	return(1);
}

/*
 *	vo_xt_win_size
 *
 * If the X toolkit has changed the window size, then
 * you might wish to call this routine to tell vogl/vogle about it.
 */
vo_xt_win_size(xw, xh)
	int	xw, xh;
{
	char	backb;

	x11->w = xw;
	x11->h = xh;

	vdevice.sizeX = vdevice.sizeY = MIN(x11->h, x11->w);
	vdevice.sizeSx = x11->w;
	vdevice.sizeSy = x11->h;

	backb = (x11->theDrawable == x11->bbuf);

	if (x11->back_used) {

		/* Have to re allocate the back buffer */

		XFreePixmap(x11->display, x11->bbuf);

		x11->bbuf = XCreatePixmap(x11->display,
			(Drawable)x11->winder,
			(unsigned int)vdevice.sizeSx + 1,
			(unsigned int)vdevice.sizeSy + 1,
			(unsigned int)vdevice.depth
		);
	}
	if (backb)
		x11->theDrawable = (Drawable)x11->bbuf;
}
#endif

/*
 * X11_winopen
 *
 *	open and/or initialises X11 display.
 */
void *
X11_winopen(const char *devname, const char *title, int id)
{
	int		i;
	int		x, y, prefx, prefy, prefxs, prefys;
	unsigned int	w, h;
	unsigned int	bw, depth, mask;
	Window		rootw, childw;
	char		*av[2], name[128], *geom;
	static Display		*display = NULL;

	XSetWindowAttributes    theWindowAttributes;
	XWindowAttributes	retWindowAttributes;
        XSizeHints              theSizeHints;
        unsigned long           theWindowMask;
	XWMHints                theWMHints;


	x11 = (X11_rec *)vallocate(sizeof(X11_rec));
	if (x11 == NULL)
		return(NULL);

	memset(x11, 0, sizeof(X11_rec));


	av[0] = me;
	av[1] = (char *)NULL;

	if (!display) {
		if ((display = XOpenDisplay(xdisp)) == (Display *)NULL) {
			fprintf(stderr,"%s: X11_init: can't connect to X server (%s)\n", me, xdisp ? xdisp : "(from env)");
			exit(1);
		}
	}
	x11->display = display;

	x11->screen = DefaultScreen(x11->display);
	x11->winder = RootWindow(x11->display, x11->screen);
	x11->id = id;
	if (getenv("USEOWNCMAP")) {
                x11->colormap = XCreateColormap(x11->display, x11->winder, DefaultVisual(x11->display, x11->screen), AllocAll);
                x11->privatecmap = 1;
        } else
		x11->colormap = DefaultColormap(x11->display, x11->screen);
	x11->depth = vdevice.depth = DefaultDepth(x11->display, x11->screen);

	/*
	 * Set our standard colors...
	 */
	if (vdevice.depth == 1) {
		/*
		 * Black and white - anything that's not black is white.
		 */
		x11->carray[0] = BlackPixel(x11->display, x11->screen);
		for (i = 1; i < CMAPSIZE; i++)
			x11->carray[i] = WhitePixel(x11->display, x11->screen);
	} else {
		/*
		 * Color, try to get our colors close to what's in the
		 * default colormap.
		 */
		X11_mapcolor(0, 0, 0, 0);
		X11_mapcolor(1, 255, 0, 0);
		X11_mapcolor(2, 0, 255, 0);
		X11_mapcolor(3, 255, 255, 0);
		X11_mapcolor(4, 0, 0, 255);
		X11_mapcolor(5, 255, 0, 255);
		X11_mapcolor(6, 0, 255, 255);
		X11_mapcolor(7, 255, 255, 255);
	}

	getprefposandsize(&prefx, &prefy, &prefxs, &prefys);

	/*
	 * NEED TO USE XGRABPOINTER here???
	 */
	XQueryPointer(x11->display, x11->winder, &rootw, &childw, &x, &y, &x, &y, &mask);

	if (childw == None)
		childw = rootw;

	XGetGeometry(x11->display, childw, &rootw, &x, &y, &w, &h, &bw, &depth);


        theWindowAttributes.backing_store = WhenMapped;
        theWindowAttributes.save_under = True;
        theWindowAttributes.border_pixel = x11->carray[1];


	/*
	 * See if there is something in the .Xdefaults file regarding
	 * VOGL/VOGLE.
	 */

	if ((x11->smallf = XGetDefault(x11->display, me, "smallfont")) == (char *)NULL)
		x11->smallf = SMALLFONT;

	if ((x11->largef = XGetDefault(x11->display, me, "largefont")) == (char *)NULL)
		x11->largef = LARGEFONT;

	geom = XGetDefault(x11->display, me, "Geometry");

	theSizeHints.flags = 0;
	w = h = 300;
	if (geom != (char *)NULL) {
		theSizeHints.flags = 0;
		printf("Got some geom\n");
		mask = XParseGeometry(geom, &x, &y, &w, &h);

		if (mask & XValue)
			theSizeHints.flags |= USPosition;

		if (mask & YValue)
			theSizeHints.flags |= USPosition;

		if (mask & WidthValue)
			theSizeHints.flags |= USSize;

		if (mask & HeightValue)
			theSizeHints.flags |= USSize;

		if (mask & XNegative)
			 x = DisplayWidth(x11->display, x11->screen) - 2*bw - w + x;

		if (mask & YNegative)
			y = DisplayHeight(x11->display, x11->screen) - 2*bw - h + y;

	}

	if (prefx > -1) {
	        x = prefx;
	        y = prefy;
		theSizeHints.flags |= USPosition;
	}

	if (prefxs > -1) {
	        w = prefxs;
	        h = prefys;
		theSizeHints.flags |= USSize;
	}

	if (bw == 0)
		bw = 4;

	x -= bw;
	y -= bw;

	if (x <= 0)
		x = 0;

	if (y <= 0)
		y = 0;

	w -= 4 * bw;
	h -= 4 * bw;

        theWindowMask = CWBorderPixel|CWBackingStore;

        x11->winder = XCreateWindow(x11->display,
                                x11->winder,
                                x, y,
                                w, h,
                                bw,
                                (int)vdevice.depth,
                                InputOutput,
                                CopyFromParent,
                                theWindowMask,
                                &theWindowAttributes
                        );
 
        theSizeHints.x = x;
        theSizeHints.y = y;
        theSizeHints.width = w;
        theSizeHints.height = h;

	x11->title = vallocate(strlen(title) + 1);
	strcpy(x11->title, title);

	XSetStandardProperties(x11->display,
		x11->winder,
		x11->title,
		x11->title,
		None,
		av,
		1,
		&theSizeHints
	);

        theWMHints.initial_state = NormalState;
        theWMHints.input = True;
        theWMHints.flags = StateHint | InputHint;
        XSetWMHints(x11->display, x11->winder, &theWMHints);

	XSelectInput(x11->display, x11->winder, EV_MASK);

	x11->theDrawable = (Drawable)x11->winder;

	/*
	 * Create Graphics Context and Drawable
	 */
	x11->theGC = XDefaultGC(x11->display, x11->screen);
	x11->theGCvalues.graphics_exposures = False;
	x11->theGCvalues.cap_style = CapButt;
	XChangeGC(x11->display, x11->theGC, GCGraphicsExposures|GCCapStyle, &x11->theGCvalues);
	x11->theDrawable = (Drawable)x11->winder;
	X11_color(0);

	XMapRaised(x11->display, x11->winder);
	XFlush(x11->display);

	/*
	 * Wait for Exposure event.
	 */
	do {
		XNextEvent(x11->display, &event);
	} while (event.type != Expose && event.type != MapNotify);

	/*
	 *  Let VOGL/VOGLE know about the window size.
	 *  (We may have been resized..... )
	 */
	if (!XGetWindowAttributes(x11->display, x11->winder, &retWindowAttributes)) {
		fprintf(stderr,"Can't get window attributes.");
		exit(1);
	}

	x = retWindowAttributes.x;
	y = retWindowAttributes.y;
	w = retWindowAttributes.width;
	h = retWindowAttributes.height;

	XTranslateCoordinates(x11->display,
			x11->winder, retWindowAttributes.root,
			0, 0,
			&x, &y,
			&rootw
	);

	vdevice.sizeX = vdevice.sizeY = MIN(h, w);
	vdevice.sizeSx = w;
	vdevice.sizeSy = h;

	if (x11->back_used && (maxw < w || maxh < h)) {
		x11->back_used = 0;
		X11_backbuf();
	}

	x11->initialized = 1;
	return((void *)x11);
}

int
X11_winset(void *p)
{
	X11_rec	*x11win = (X11_rec *)p;

	if (!x11win)
		return(0);

	x11 = x11win;
	return(1);
}

int
X11_winclose(void *p)
{
	X11_rec	*x11win = (X11_rec *)p;
	/* Make it an icon */
}

/*
 * X11_exit
 *
 *	cleans up before returning the window to normal.
 */
int
X11_windel(void *p)
{
	X11_rec	*x11win = (X11_rec *)p;

	if (x11win->back_used) 
		XFreePixmap(x11->display, x11->bbuf);

	if (x11win->font_id != (XFontStruct *)NULL)
		XFreeFont(x11win->display, x11win->font_id);

	x11win->font_id = (XFontStruct *)NULL;

#ifdef NEWCMAP
        if (colormap != DefaultColormap(display, screen))
                XFreeColormap(display, colormap);

        colormap = 0;
#endif

	/* Free the GC */


	XDestroyWindow(x11win->display, x11win->winder);

	XSync(x11win->display, 0);

	/*XCloseDisplay(x11win->display);*/

	if (x11win->title)
		free(x11win->title);

	free(x11win);

	return(1);
}

/*
 * X11_draw
 *
 *	draws a line from the current graphics position to (x, y).
 *
 * Note: (0, 0) is defined as the top left of the window in X (easy
 * to forget).
 */
int
X11_draw(int x, int y)
{
	XDrawLine(x11->display,
		x11->theDrawable,
		x11->theGC,
		vdevice.cpVx, vdevice.sizeSy - vdevice.cpVy,
		x, vdevice.sizeSy - y
	);

	if (vdevice.sync)
		XSync(x11->display, 0);
}

int
X11_pnt(int x, int y)
{
	XDrawPoint(x11->display,
		x11->theDrawable,
		x11->theGC,
		x, vdevice.sizeSy - y
	);

	if (vdevice.sync)
		XSync(x11->display, 0);
}

/*
 * X11_getkey
 *
 *	grab a character from the keyboard - blocks until one is there.
 */
int
X11_getkey(void)
{
	char	c;

	do {
		XNextEvent(x11->display, &event);
		if (event.type == KeyPress) {
			if (XLookupString((XKeyEvent *)&event, &c, 1, NULL, NULL) > 0)
				return((int)c);
			else
				return(0);
		}
	} while (event.type != KeyPress);
}

Vevent *
X11_event(void)
{
	static Vevent	vev;

	if (!XCheckMaskEvent(x11->display, Expose|KeyPressMask|ButtonPressMask, &event))
		return(NULL);

	switch(event.type) {
	case KeyPress:
		vev.type = VKEYPRESS;
		if (XLookupString((XKeyEvent *)&event, &c, 1, NULL, NULL) > 0)
			vev.data = c;

		printf("KeyPress %c\n", vev.data);
		break;
	case ButtonPress:
		vev.type = VBUTTONPRESS;
		vev.data = event.state;
		printf("ButtonPress %c\n", vev.data);
		berak;
	case Expose:
		vev.type = VREDRAW;
		vev.data = 0;
		printf("Expose\n");
		break;
	case ConfigureNotify:
		vev.type = VRESIZE;
		vev.data = 0;
		printf("ConfigureNotify\n");
		break;
	default:
		vev.type = 0;
		vev.data = 0;
	}

	return(&vev);
}
	
/*
 * X11_checkkey
 *
 *	Check if there has been a keyboard key pressed.
 *	and return it if there is.
 */
int
X11_checkkey(void)
{
	char	c;

	if (!XCheckWindowEvent(x11->display, x11->winder, Expose|KeyPressMask, &event))
		return(0);

	if (event.type == KeyPress) {
		if (XLookupString((XKeyEvent *)&event, &c, 1, NULL, NULL) > 0)
			return((int)c);

	} else if (event.type == Expose) {
		/*
		 * Resize the viewport
		 */
	}
	return(0);
}

/*
 * X11_locator
 *
 *	return the window location of the cursor, plus which mouse button,
 * if any, is been pressed.
 */
int
X11_locator(int *wx, int *wy)
{
	Window		rootw, childw;
	int		x, y;
	unsigned int	mask;

	XQueryPointer(x11->display, x11->winder, &rootw, &childw, &x, &y, wx, wy, &mask);

	*wy = (int)vdevice.sizeSy - *wy;

	return(mask >> 8);
}

#ifdef VOGLE
/*
 * X11_clear
 *
 * Clear the screen (or current buffer )to current colour
 */
int
X11_clear(void)
{
	XSetBackground(x11->display, x11->theGC, x11->colour);
	XFillRectangle(x11->display,
		x11->theDrawable,
		x11->theGC,
		0,
		0,
		(unsigned int)vdevice.sizeSx + 1,
		(unsigned int)vdevice.sizeSy + 1
	);

	if (vdevice.sync)
		XFlush(x11->display);
}

#else 

/*
 * X11_clear
 *
 * Clear the screen (or current buffer )to current colour
 */
int
X11_clear(void)
{
	unsigned int	w = vdevice.maxVx - vdevice.minVx;
	unsigned int	h = vdevice.maxVy - vdevice.minVy;

	XSetBackground(x11->display, x11->theGC, x11->colour);

	XFillRectangle(x11->display,
		x11->theDrawable,
		x11->theGC,
		vdevice.minVx,
		vdevice.sizeSy - vdevice.maxVy, 
		w, 
		h
	);

	if (vdevice.sync)
		XFlush(x11->display);
}
#endif

/*
 * X11_color
 *
 *	set the current drawing color index.
 */
int
X11_color(int ind)
{
	x11->colour = x11->carray[ind];
	XSetForeground(x11->display, x11->theGC, x11->colour);
}

int
RGBcolor(short r, short g, short b)
{
	x11->colour = (r << 16) + (g << 8) + b;
	XSetForeground(x11->display, x11->theGC, x11->colour);
}

/*
 * X11_mapcolor
 *
 *	change index i in the color map to the appropriate r, g, b, value.
 */
int
X11_mapcolor(int i, int r, int g, int b)
{
	int	stat;
	XColor	tmp;

	if (i >= CMAPSIZE)
		return(-1);


	/*
	 * For Black and White.
	 * If the index is 0 and r,g,b != 0 then we are remapping black.
	 * If the index != 0 and r,g,b == 0 then we make it black.
	 */
	if (vdevice.depth == 1) {
		if (i == 0 && (r != 0 || g != 0 || b != 0)) 
			x11->carray[i] = WhitePixel(x11->display, x11->screen);
		else if (i != 0 && r == 0 && g == 0 && b == 0)
			x11->carray[i] = BlackPixel(x11->display, x11->screen);
	} else {
		tmp.red = (unsigned short)(r / 255.0 * 65535);
		tmp.green = (unsigned short)(g / 255.0 * 65535);
		tmp.blue = (unsigned short)(b / 255.0 * 65535);
		tmp.flags = 0;
		tmp.pixel = (unsigned long)i;

                if (x11->privatecmap) {
                        XStoreColor(x11->display, x11->colormap, &tmp);
                } else if ((stat = XAllocColor(x11->display, x11->colormap, &tmp)) == 0) {
                        fprintf(stderr, "XAllocColor failed, try setenv USEOWNCMAP 1'\n");
                        exit(1);
                }
		x11->carray[i] = tmp.pixel;
	}

	XFlush(x11->display);
	return(0);
}
	
/*
 * X11_font
 *
 *   Set up a hardware font. Return 1 on success 0 otherwise.
 *
 */
int
X11_font(const char *fontfile)
{
	XGCValues	xgcvals;
	char	*name = (char *)fontfile;

	if (x11->font_id != (XFontStruct *)NULL)
		XFreeFont(x11->display, x11->font_id);

	if (strcmp(fontfile, "small") == 0) {
		if ((x11->font_id = XLoadQueryFont(x11->display, x11->smallf)) == (XFontStruct *)NULL) {
			fprintf(stderr, "%s X11.c couldn't open small font '%s'\n", me, x11->smallf);
			fprintf(stderr, "You'll have to redefine it....\n");
			return(0);
		} else
			name = x11->smallf;
		
	} else if (strcmp(fontfile, "large") == 0) {
		if ((x11->font_id = XLoadQueryFont(x11->display, x11->largef)) == (XFontStruct *)NULL) {
			fprintf(stderr, "%s X11.c couldn't open large font '%s'\n", me, x11->largef);
			fprintf(stderr, "You'll have to redefine it....\n");
			return(0);
		}
			name = x11->largef;
	} else {
		if ((x11->font_id = XLoadQueryFont(x11->display, fontfile)) == (XFontStruct *)NULL) {
			fprintf(stderr, "%s X11.c couldn't open fontfile '%s'\n", me, fontfile);
			return(0);
		}
	}

	vdevice.hheight = x11->font_id->max_bounds.ascent + x11->font_id->max_bounds.descent;
	vdevice.hwidth = x11->font_id->max_bounds.width;

	xgcvals.font = XLoadFont(x11->display, name);
	XChangeGC(x11->display, x11->theGC, GCFont, &xgcvals);

	return(1);
}

/* 
 * X11_char
 *
 *	 outputs one char - is more complicated for other devices
 */
int
X11_char(char c)
{
	char	*s = " ";

	s[0] = c;
	XDrawString(x11->display, x11->theDrawable, x11->theGC, vdevice.cpVx, (int)(vdevice.sizeSy - vdevice.cpVy), s, 1);

	if (vdevice.sync)
		XFlush(x11->display);
}

/*
 * X11_string
 *
 *	Display a string at the current drawing position.
 */
int
X11_string(const char *s)
{
	XDrawString(x11->display, x11->theDrawable, x11->theGC, vdevice.cpVx, (int)(vdevice.sizeSy - vdevice.cpVy), s, strlen(s));
	if (vdevice.sync)
		XFlush(x11->display);
}

/*
 * X11_fill
 *
 *	fill a polygon
 */
int
X11_fill(int n, int x[], int y[])
{
	char	buf[BUFSIZ];
	XPoint	plist[MAXPNTS];
	int	i;

	if (n > MAXPNTS) {
		return(0);
	}

	for (i = 0; i < n; i++) {
		plist[i].x = x[i];
		plist[i].y = vdevice.sizeSy - y[i];
	}

	XFillPolygon(x11->display, x11->theDrawable, x11->theGC, plist, n, Nonconvex, CoordModeOrigin);

	vdevice.cpVx = x[n-1];
	vdevice.cpVy = y[n-1];

	if (vdevice.sync)
		XFlush(x11->display);
}

/*
 * X11_backbuf
 *
 *	Set up double buffering by allocating the back buffer and
 *	setting drawing into it.
 */
int
X11_backbuf(void)
{
	if (!x11->back_used) {
		x11->bbuf = XCreatePixmap(x11->display,
			(Drawable)x11->winder,
			(unsigned int)vdevice.sizeSx + 1,
			(unsigned int)vdevice.sizeSy + 1,
			(unsigned int)vdevice.depth
		);

		maxw = MAX(vdevice.sizeSx + 1, maxw);
		maxh = MAX(vdevice.sizeSy + 1, maxh);
	}

	x11->theDrawable = (Drawable)x11->bbuf;

	x11->back_used = 1;

	return(1);
}

/*
 * X11_swapbuf
 *
 *	Swap the back and from buffers. (Really, just copy the
 *	back buffer to the screen).
 */
int
X11_swapbuf(void)
{
	XCopyArea(x11->display,
		x11->theDrawable,
		x11->winder,
		x11->theGC,
		0, 0,
		(unsigned int)vdevice.sizeSx + 1,
		(unsigned int)vdevice.sizeSy + 1,
		0, 0
	);
	XFlush(x11->display);
}

/*
 * X11_frontbuf
 *
 *	Make sure we draw to the screen.
 */
int
X11_frontbuf(void)
{
	x11->theDrawable = (Drawable)x11->winder;
}

/*
 * Syncronise the display with what we think has been sent to it...
 */
int
X11_sync(void)
{
	XSync(x11->display, 0);
}

#undef VORTDUMP
#ifdef VORTDUMP
/*
 * HACK
 * Dump the contents of the current buffer to a VORT file....
 * ONLY WORKS WITH 8Bit Drawables!
 */
#include "vort.h"

void
X11_dump_pixmap(const char *filename, int dx, int dy, int dw, int dh)
{
	XImage	*ximage;
	image	*im;
	unsigned char	*line, *rm, *gm, *bm;
	XColor	*cols;
	int	i;

	if (dw > vdevice.sizeSx || dw < 0)
		dw = vdevice.sizeSx;
	if (dh > vdevice.sizeSy || dh < 0)
		dh = vdevice.sizeSy;

	if (dx > vdevice.sizeSx || dx < 0)
		dx = 0;
	if (dy > vdevice.sizeSy || dy < 0)
		dy = 0;

	ximage = XGetImage(x11->display, 
			x11->theDrawable, 
			dx, dy,
			(unsigned int)dw,
			(unsigned int)dh,
			AllPlanes,
			ZPixmap
		);

	if (!ximage) {
		fprintf(stderr, "X11_dump_pixmap: can't do XGetImage\n");
		exit(1);
	}

	if ((im = openimage(filename, "w")) == (image *)NULL) {
		fprintf(stderr, "X11_dump_pixmap: can't open %s\n", filename);
		exit(1);
	}

	if (!(rm = (unsigned char *)malloc(256))) {
		fprintf(stderr, "X11_dump_pixmap: can't alloc rm\n");
		exit(1);
	}
	if (!(gm = (unsigned char *)malloc(256))) {
		fprintf(stderr, "X11_dump_pixmap: can't alloc gm\n");
		exit(1);
	}
	if (!(bm = (unsigned char *)malloc(256))) {
		fprintf(stderr, "X11_dump_pixmap: can't alloc bm\n");
		exit(1);
	}
	if (!(cols = (XColor *)malloc(256 * sizeof(XColor)))) {
		fprintf(stderr, "X11_dump_pixmap: can't alloc cols\n");
		exit(1);
	}

	/*
	 * Get our colormap...
	 */
	for (i = 0; i < 256; i++) {
		cols[i].pixel = (unsigned long)i;
		cols[i].red = cols[i].green = cols[i].blue = 0;
		cols[i].flags = DoRed | DoGreen | DoBlue;
	}

	XQueryColors(x11->display, x11->colormap, cols, 256);

	for (i = 0; i < 256; i++) {
		rm[i] = (unsigned char)(cols[i].red >> 8);
		gm[i] = (unsigned char)(cols[i].green >> 8);
		bm[i] = (unsigned char)(cols[i].blue >> 8);
	}

	imagetype(im) = PIX_RLECMAP;
	imageheight(im) = dh;
	imagewidth(im) = dw;
	imagedate(im) = time(0);
	titlelength(im) = 0;
	setcmap(im, 256, rm, gm, bm);

	writeheader(im);

	line = (unsigned char *)ximage->data;
	for (i = 0; i < dh; i++) {
		writemappedline(im, line);
		line += ximage->bytes_per_line;
	}
	
	closeimage(im); 

	free(rm);
	free(gm);
	free(bm);
	free(cols);
	XDestroyImage(ximage);
}

#endif

#ifndef VOGLE
/*
 * X11_setlw
 *
 *	Set the line width....
 */
int
X11_setlw(int w)
{
	XGCValues vals;

	vals.line_width = w;
	XChangeGC(x11->display, x11->theGC, GCLineWidth, &vals);
}

/*
 * X11_setls
 *
 *	Set the line style....
 */

int
X11_setls(int lss)
{
	unsigned ls = lss;
	char	dashes[16];
	int	i, n, a, b, offset;

	if (ls == 0xffff) {
		XSetLineAttributes(x11->display, x11->theGC, vdevice.attr->a.lw, LineSolid, CapButt, JoinMiter);
		return;
	}

	for (i = 0; i < 16; i++)
		dashes[i] = 0;

	for (i = 0; i < 16; i++)	/* Over 16 bits */
		if ((ls & (1 << i)))
			break;

	offset = i;

#define	ON	1
#define	OFF	0
		
	a = b = OFF;
	if (ls & (1 << 0))
		a = b = ON;

	n = 0;
	for (i = 0; i < 16; i++) {	/* Over 16 bits */
		if (ls & (1 << i))
			a = ON;
		else
			a = OFF;

		if (a != b) {
			b = a;
			n++;
		}
		dashes[n]++;
	}
	n++;

	XSetLineAttributes(x11->display, x11->theGC, vdevice.attr->a.lw, LineOnOffDash, CapButt, JoinMiter);
	XSetDashes(x11->display, x11->theGC, offset, dashes, n);
}

#else

/*
 * X11_setlw
 *
 *	Set the line width....
 */
int 
X11_setlw(int w)
{
	XGCValues vals;

	if (w != 0)
		w = 3;

	vals.line_width = w;
	XChangeGC(x11->display, x11->theGC, GCLineWidth, &vals);
}

#endif 

/*
 * the device entry
 */
static DevEntry X11dev = {
	"X11",
	"large",
	"small",
	X11_backbuf,
	X11_char,
	X11_checkkey,
	X11_clear,
	X11_color,
	X11_draw,
	X11_fill,
	X11_font,
	X11_frontbuf,
	X11_getkey,
	X11_winopen,
	X11_winset,
	X11_winclose,
	X11_windel,
	X11_locator,
	X11_mapcolor,
	X11_pnt,
#ifndef VOGLE
	X11_setls,
#endif
	X11_setlw,
	X11_string,
	X11_swapbuf,
	X11_sync
};

/*
 * _X11_devcpy
 *
 *	copy the X11 device into vdevice.dev.
 */
_X11_devcpy(const char *devname)
{
	vdevice.dev = X11dev;
}
